import Foundation

/// Agent for malware and adware detection
actor MalwareAgent {
    private let fileManager = FileManager.default
    
    /// Known malware/adware paths and patterns
    private let suspiciousPaths: [(path: String, name: String, threat: ThreatLevel)] = [
        // LaunchAgents
        ("~/Library/LaunchAgents/com.vsearch*.plist", "VSearch Adware", .high),
        ("~/Library/LaunchAgents/com.genieo*.plist", "Genieo Adware", .high),
        ("~/Library/LaunchAgents/com.conduit*.plist", "Conduit Adware", .high),
        ("~/Library/LaunchAgents/com.crossrider*.plist", "Crossrider Adware", .high),
        ("~/Library/LaunchAgents/com.spigot*.plist", "Spigot Adware", .medium),
        ("~/Library/LaunchAgents/com.operatorMac*.plist", "OperatorMac Adware", .high),
        
        // Application Support
        ("~/Library/Application Support/VSearch", "VSearch Adware", .high),
        ("~/Library/Application Support/Genieo", "Genieo Adware", .high),
        ("~/Library/Application Support/Spigot", "Spigot Adware", .medium),
        
        // Browser extensions
        ("~/Library/Safari/Extensions/*.safariextz", "Safari Extensions", .low),
        
        // Known malware locations
        ("/Library/LaunchDaemons/com.apple.installer.*", "Suspicious Installer", .medium),
        ("~/Library/Caches/.com.apple.*", "Hidden Cache (suspicious)", .low),
    ]
    
    /// Scan for malware
    func scan(progress: @escaping (Double, String) -> Void) async -> [ThreatItem] {
        var threats: [ThreatItem] = []
        let home = fileManager.homeDirectoryForCurrentUser.path
        
        for (index, item) in suspiciousPaths.enumerated() {
            let progressValue = Double(index) / Double(suspiciousPaths.count)
            progress(progressValue, "Checking \(item.name)...")
            
            let expandedPath = item.path.replacingOccurrences(of: "~", with: home)
            
            // Handle wildcards
            if expandedPath.contains("*") {
                let basePath = (expandedPath as NSString).deletingLastPathComponent
                let pattern = (expandedPath as NSString).lastPathComponent
                
                if let contents = try? fileManager.contentsOfDirectory(atPath: basePath) {
                    for file in contents {
                        if matchesPattern(file, pattern: pattern) {
                            let fullPath = (basePath as NSString).appendingPathComponent(file)
                            threats.append(ThreatItem(
                                path: URL(fileURLWithPath: fullPath),
                                name: item.name,
                                threatLevel: item.threat,
                                details: "Found: \(file)"
                            ))
                        }
                    }
                }
            } else if fileManager.fileExists(atPath: expandedPath) {
                threats.append(ThreatItem(
                    path: URL(fileURLWithPath: expandedPath),
                    name: item.name,
                    threatLevel: item.threat,
                    details: "Found at \(expandedPath)"
                ))
            }
        }
        
        // Also check for unsigned apps
        progress(0.9, "Checking for suspicious apps...")
        threats.append(contentsOf: await scanForSuspiciousApps())
        
        progress(1.0, "Scan complete")
        return threats.sorted { $0.threatLevel.rawValue > $1.threatLevel.rawValue }
    }
    
    /// Scan for unsigned or suspicious applications
    private func scanForSuspiciousApps() async -> [ThreatItem] {
        var threats: [ThreatItem] = []
        let applicationsPath = "/Applications"
        
        guard let apps = try? fileManager.contentsOfDirectory(atPath: applicationsPath) else {
            return []
        }
        
        // Known potentially unwanted apps
        let pups = ["MacKeeper", "MacCleaner", "MacBooster", "Advanced Mac Cleaner", "Mac Auto Fixer"]
        
        for app in apps {
            for pup in pups {
                if app.lowercased().contains(pup.lowercased()) {
                    threats.append(ThreatItem(
                        path: URL(fileURLWithPath: "/Applications/\(app)"),
                        name: "Potentially Unwanted Program",
                        threatLevel: .medium,
                        details: "App may contain unwanted behavior: \(app)"
                    ))
                }
            }
        }
        
        return threats
    }
    
    /// Check if filename matches wildcard pattern
    private func matchesPattern(_ filename: String, pattern: String) -> Bool {
        let regex = pattern
            .replacingOccurrences(of: ".", with: "\\.")
            .replacingOccurrences(of: "*", with: ".*")
        
        return filename.range(of: regex, options: .regularExpression) != nil
    }
    
    /// Remove threat
    func removeThreat(_ threat: ThreatItem) async throws {
        try fileManager.trashItem(at: threat.path, resultingItemURL: nil)
    }
}

/// Threat item model
struct ThreatItem: Identifiable {
    let id = UUID()
    let path: URL
    let name: String
    let threatLevel: ThreatLevel
    let details: String
    var isSelected: Bool = false
}

/// Threat severity levels
enum ThreatLevel: Int, Comparable {
    case low = 1
    case medium = 2
    case high = 3
    
    var color: String {
        switch self {
        case .low: return "yellow"
        case .medium: return "orange"
        case .high: return "red"
        }
    }
    
    var label: String {
        switch self {
        case .low: return "Low Risk"
        case .medium: return "Medium Risk"
        case .high: return "High Risk"
        }
    }
    
    static func < (lhs: ThreatLevel, rhs: ThreatLevel) -> Bool {
        lhs.rawValue < rhs.rawValue
    }
}
